{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","PathfindingVisualizer/algorithms/dijkstra.js","PathfindingVisualizer/algorithms/BFS.js","PathfindingVisualizer/algorithms/DFS.js","PathfindingVisualizer/algorithms/aStar.js","PathfindingVisualizer/algorithms/greedy.js","PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","index.js"],"names":["Node","this","props","col","row","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseMove","onMouseUp","extraClassName","f","h","id","className","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","getDistance","distanceToCompare","previousNode","node1","node2","x1","x2","y1","y2","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","unshift","shortestPathOrder","aStar","manhattanDistance","Math","abs","greedy","PathfindingVisualizer","state","mouseIsPressed","start_row","start_col","finish_row","finish_col","setStart","setFinish","intro","introJs","setOptions","steps","element","document","getElementById","position","start","currentRow","createNode","newGrid","slice","newNode","getInitialGrid","setState","getNewGridWithWallToggled","r","c","n","newN","i","setTimeout","animateShortestPath","clearPath","animateDijkstra","visitedNodes","BFS","nodeShortestPathOrder","pop","DFS","onClick","visualizeDijkstra","visualizeBFS","visualizeDFS","visualizeAStar","visualizeGreedy","clearBoard","style","paddingLeft","icon","faInfoCircle","touchRadius","startIntro","color","map","rowIdx","key","nodeIdx","handleMouseMove","handleMouseDown","handleMouseEnter","handleMouseUp","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.ec0ed7a1.chunk.js","sourcesContent":["import React, { Component } from \"react\";\n\nimport \"./Node.css\";\n\nexport default class Node extends Component {\n  render() {\n    const {\n      col,\n      row,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseMove,\n      onMouseUp,\n      f,\n      h\n    } = this.props;\n    const extraClassName = isFinish\n      ? \"node-finish\"\n      : isStart\n      ? \"node-start\"\n      : isWall\n      ? \"node-wall\"\n      : \"\";\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={() => onMouseDown(row, col, isFinish, isStart)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseMove={() => onMouseMove(row, col)}\n        onMouseUp={() => onMouseUp()}\n      ></div>\n    );\n  }\n}\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    const distance = getDistance(node, neighbor);\n    const distanceToCompare = node.distance + distance;\n    if (distanceToCompare < neighbor.distance) {\n      neighbor.distance = distanceToCompare;\n      neighbor.previousNode = node;\n    }\n  }\n}\nfunction getDistance(node1, node2) {\n  const x1 = node1.row;\n  const x2 = node2.row;\n  const y1 = node1.col;\n  const y2 = node2.col;\n  if (x2 < x1 && y1 === y2) return 3;\n  else if (x2 > x1 && y1 === y2) return 3;\n  else if (y2 < y1 && x1 === x2) return 1;\n  else if (y2 > y1 && x1 === x2) return 1;\n}\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","export function BFS(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n\n  const unvisitedNodes = [startNode];\n  while (!!unvisitedNodes.length) {\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid, unvisitedNodes);\n  }\n}\n\nfunction updateUnvisitedNeighbors(node, grid, unvisitedNodes) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.isVisited = true;\n    unvisitedNodes.push(neighbor);\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nexport function shortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","export function DFS(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n\n  const unvisitedNodes = [startNode];\n  while (!!unvisitedNodes.length) {\n    const closestNode = unvisitedNodes.pop();\n\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid, unvisitedNodes);\n  }\n}\n\nfunction updateUnvisitedNeighbors(node, grid, unvisitedNodes) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    unvisitedNodes.push(neighbor);\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.unshift(grid[row - 1][col]);\n  if (col < grid[0].length - 1) neighbors.unshift(grid[row][col + 1]);\n  if (row < grid.length - 1) neighbors.unshift(grid[row + 1][col]);\n  if (col > 0) neighbors.unshift(grid[row][col - 1]);\n\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n","export function aStar(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  startNode.f = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid, finishNode);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.f - nodeB.f);\n}\n\nfunction updateUnvisitedNeighbors(node, grid, finishNode) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    const distance = getDistance(node, neighbor);\n    if (neighbor.h === Infinity) {\n      neighbor.h = manhattanDistance(neighbor, finishNode);\n    }\n\n    const distanceToCompare = node.distance + distance;\n    if (distanceToCompare < neighbor.distance) {\n      neighbor.distance = distanceToCompare;\n      neighbor.previousNode = node;\n      neighbor.f = neighbor.distance + neighbor.h;\n    }\n  }\n}\nfunction manhattanDistance(node1, node2) {\n  const d1 = Math.abs(node1.row - node2.row);\n  const d2 = Math.abs(node1.col - node2.col);\n  return d1 + d2;\n}\nfunction getDistance(node1, node2) {\n  const x1 = node1.row;\n  const x2 = node2.row;\n  const y1 = node1.col;\n  const y2 = node2.col;\n  if (x2 < x1 && y1 === y2) return 3;\n  else if (x2 > x1 && y1 === y2) return 3;\n  else if (y2 < y1 && x1 === x2) return 1;\n  else if (y2 > y1 && x1 === x2) return 1;\n}\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n","export function greedy(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid, finishNode);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid, finishNode) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    const distance = getDistance(node, neighbor);\n    const distanceToCompare =\n      manhattanDistance(neighbor, finishNode) + distance;\n    if (distanceToCompare < neighbor.distance) {\n      neighbor.distance = distanceToCompare;\n      neighbor.previousNode = node;\n    }\n  }\n}\nfunction manhattanDistance(node1, node2) {\n  const d1 = Math.abs(node1.row - node2.row);\n  const d2 = Math.abs(node1.col - node2.col);\n  return d1 + d2;\n}\nfunction getDistance(node1, node2) {\n  const x1 = node1.row;\n  const x2 = node2.row;\n  const y1 = node1.col;\n  const y2 = node2.col;\n  if (x2 < x1 && y1 === y2) return 3;\n  else if (x2 > x1 && y1 === y2) return 3;\n  else if (y2 < y1 && x1 === x2) return 1;\n  else if (y2 > y1 && x1 === x2) return 1;\n}\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","import React, { Component } from \"react\";\nimport Node from \"./Node/Node\";\nimport { dijkstra, getNodesInShortestPathOrder } from \"./algorithms/dijkstra\";\nimport { BFS, shortestPathOrder } from \"./algorithms/BFS\";\nimport { DFS } from \"./algorithms/DFS\";\nimport { aStar } from \"./algorithms/aStar\";\nimport { greedy } from \"./algorithms/greedy\";\nimport \"./PathfindingVisualizer.css\";\nimport introJs from 'intro.js';\nimport 'intro.js/introjs.css';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faInfoCircle } from '@fortawesome/free-solid-svg-icons';\n\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n      start_row: 10,\n      start_col: 10,\n      finish_row: 10,\n      finish_col: 35,\n      setStart: false,\n      setFinish: false\n    };\n  }\n startIntro(){\n    var intro = introJs();\n      intro.setOptions({\n        steps: [\n          { \n            intro: \"Thank you for playing with PathVisualizer\"\n          },\n          { \n            intro: \"Use mouse to choose your Start <b>(yellow icon)</b> and End <b>(pink icon)</b> position.\"\n          },\n          {\n\n            intro: \"Click at any other position to set up Walls\"\n          },\n          {\n            element: document.getElementById(\"algorithm\"),\n            intro: \"Play with different Graph Algorithms here\",\n            position: 'bottom'\n          },\n          {\n            element: document.getElementById(\"path\"),\n            intro: \"Clear out current path here\",\n            position: 'bottom'\n          },\n          {\n            element: document.getElementById(\"board\"),\n            intro: \"Clear out current wall here\",\n            position: 'bottom'\n          }\n        ]\n      });\n\n      intro.start();\n  }\n  createNode(col, row) {\n    return {\n      col,\n      row,\n      isStart: row === this.state.start_row && col === this.state.start_col,\n      isFinish: row === this.state.finish_row && col === this.state.finish_col,\n      distance: Infinity,\n      isVisited: false,\n      isWall: false,\n      previousNode: null,\n      f: Infinity,\n      h: Infinity\n    };\n  }\n  getInitialGrid() {\n    const grid = [];\n    for (let row = 0; row < 25; row++) {\n      const currentRow = [];\n      for (let col = 0; col < 42; col++) {\n        const node = this.createNode(col, row);\n        currentRow.push(node);\n      }\n      grid.push(currentRow);\n    }\n    return grid;\n  }\n\n  getNewGridWithWallToggled(grid, row, col) {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    const newNode = {\n      ...node,\n      isWall: !node.isWall\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n  }\n\n  componentDidMount() {\n    const grid = this.getInitialGrid();\n    this.setState({ grid });\n    \n  }\n\n  handleMouseDown(row, col, isFinish, isStart) {\n    if (isFinish) {\n      this.setState({ setFinish: true });\n    } else if (isStart) {\n      this.setState({ setStart: true });\n    } else {\n      const newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\n      this.setState({ grid: newGrid, mouseIsPressed: true });\n    }\n  }\n\n  handleMouseMove(row, col) {\n    if (this.state.setFinish) {\n      for (let r = 0; r < 25; r++) {\n        for (let c = 0; c < 42; c++) {\n          const n = this.state.grid[r][c];\n          if (n.isFinish) {\n            const newN = {\n              ...n,\n              isFinish: !n.isFinish\n            };\n            this.state.grid[r][c] = newN;\n          }\n        }\n      }\n      const node = this.state.grid[row][col];\n      const newNode = {\n        ...node,\n        isFinish: true\n      };\n      this.state.grid[row][col] = newNode;\n      this.setState({ finish_row: row, finish_col: col });\n    } else if (this.state.setStart) {\n      for (let r = 0; r < 25; r++) {\n        for (let c = 0; c < 42; c++) {\n          const n = this.state.grid[r][c];\n          if (n.isStart) {\n            const newN = {\n              ...n,\n              isStart: !n.isStart\n            };\n            this.state.grid[r][c] = newN;\n          }\n        }\n      }\n      const node = this.state.grid[row][col];\n      const newNode = {\n        ...node,\n        isStart: true\n      };\n      this.state.grid[row][col] = newNode;\n      this.setState({ start_row: row, start_col: col });\n    }\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.mouseIsPressed) return;\n    const newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({ grid: newGrid });\n  }\n\n  handleMouseUp() {\n    this.setState({ mouseIsPressed: false, setFinish: false, setStart: false });\n  }\n  clearBoard() {\n    const { grid } = this.state;\n\n    for (let row = 0; row < 25; row++) {\n      for (let col = 0; col < 42; col++) {\n        const node = grid[row][col];\n        if (node.isStart || node.isFinish) {\n        } else {\n          document.getElementById(`node-${row}-${col}`).className = \"node \";\n        }\n        node.isWall = false;\n        node.distance = Infinity;\n        node.isVisited = false;\n        node.previousNode = null;\n        node.f = Infinity;\n        node.h = Infinity;\n        grid[row][col] = node;\n      }\n    }\n    this.setState({ grid });\n  }\n  clearPath() {\n    const { grid } = this.state;\n\n    for (let row = 0; row < 25; row++) {\n      for (let col = 0; col < 42; col++) {\n        const node = grid[row][col];\n        if (node.isStart || node.isFinish || node.isWall) {\n        } else {\n          document.getElementById(`node-${row}-${col}`).className = \"node \";\n          node.isWall = false;\n        }\n        node.distance = Infinity;\n        node.isVisited = false;\n        node.previousNode = null;\n        node.f = Infinity;\n        node.h = Infinity;\n        grid[row][col] = node;\n      }\n    }\n    this.setState({ grid });\n  }\n\n  animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 1; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length - 1) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 6 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-visited\";\n      }, 5 * i);\n    }\n  }\n\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 2; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i - 1];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest-path\";\n      }, 25 * i);\n    }\n  }\n\n  visualizeDijkstra() {\n    this.clearPath();\n    const { grid } = this.state;\n    const startNode = grid[this.state.start_row][this.state.start_col];\n    const finishNode = grid[this.state.finish_row][this.state.finish_col];\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  visualizeAStar() {\n    this.clearPath();\n    const { grid } = this.state;\n    const startNode = grid[this.state.start_row][this.state.start_col];\n    const finishNode = grid[this.state.finish_row][this.state.finish_col];\n    const visitedNodesInOrder = aStar(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  visualizeGreedy() {\n    this.clearPath();\n    const { grid } = this.state;\n    const startNode = grid[this.state.start_row][this.state.start_col];\n    const finishNode = grid[this.state.finish_row][this.state.finish_col];\n    const visitedNodesInOrder = greedy(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  visualizeBFS() {\n    this.clearPath();\n    const { grid } = this.state;\n    const startNode = grid[this.state.start_row][this.state.start_col];\n    const finishNode = grid[this.state.finish_row][this.state.finish_col];\n    const visitedNodes = BFS(grid, startNode, finishNode);\n    const nodeShortestPathOrder = shortestPathOrder(finishNode);\n    this.animateDijkstra(visitedNodes, nodeShortestPathOrder);\n  }\n\n  visualizeDFS() {\n    this.clearPath();\n    const { grid } = this.state;\n    const startNode = grid[this.state.start_row][this.state.start_col];\n    const finishNode = grid[this.state.finish_row][this.state.finish_col];\n    const visitedNodes = DFS(grid, startNode, finishNode);\n    const nodeShortestPathOrder = shortestPathOrder(finishNode);\n    this.animateDijkstra(visitedNodes, nodeShortestPathOrder);\n  }\n  render() {\n    const { grid, mouseIsPressed } = this.state;\n\n    return (\n      <>\n        <div className=\"container\">\n        <div className=\"bars\" id=\"algorithm\">\n         <button onClick={() => this.visualizeDijkstra()}>\n            Dijkstra's Algorithm\n          </button>\n          <button onClick={() => this.visualizeBFS()}>\n            Breadth-first Search Algorithm\n          </button>\n          <button onClick={() => this.visualizeDFS()}>\n            Depth-first Search Algorithm\n          </button>\n          <button onClick={() => this.visualizeAStar()}>\n            A * Search Algorithm\n          </button>\n          <button onClick={() => this.visualizeGreedy()}>\n            Greedy Best-first Search Algorithm\n          </button>\n          \n          <button id=\"board\" onClick={() => this.clearBoard()}>Clear Board</button>\n          <button id=\"path\" onClick={() => this.clearPath()}>Clear Path</button>\n          <FontAwesomeIcon style={{paddingLeft: \"20px\"}} icon={faInfoCircle} touchRadius=\"18\" onClick={() => this.startIntro()} color=\"red\"/>\n        </div>\n        </div>\n        <div className=\"grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const { row, col, isFinish, isStart, isWall } = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      row={row}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      isWall={isWall}\n                      mouseIsPressed={mouseIsPressed}\n                      onMouseMove={(row, col) => this.handleMouseMove(row, col)}\n                      onMouseDown={(row, col, isFinish, isStart) =>\n                        this.handleMouseDown(row, col, isFinish, isStart)\n                      }\n                      onMouseEnter={(row, col) =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseMove={(row, col) => this.handleMouseMove(row, col)}\n                      onMouseUp={() => this.handleMouseUp()}\n                    ></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </>\n    );\n  }\n}\n","import React from \"react\";\nimport \"./App.css\";\nimport HighlightIcon from \"@material-ui/icons/Highlight\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer\";\n\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header>\n        <h1>\n          <HighlightIcon />\n          Path Visualizer\n          \n        </h1>\n            \n      </header>\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n"],"sourceRoot":""}