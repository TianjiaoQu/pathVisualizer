{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","PathfindingVisualizer/algorithms/dijkstra.js","PathfindingVisualizer/algorithms/BFS.js","PathfindingVisualizer/algorithms/DFS.js","PathfindingVisualizer/algorithms/aStar.js","PathfindingVisualizer/algorithms/greedy.js","PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","index.js"],"names":["Node","this","props","col","row","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseMove","onMouseUp","extraClassName","f","h","id","className","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","getDistance","distanceToCompare","previousNode","node1","node2","x1","x2","y1","y2","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","unshift","shortestPathOrder","aStar","manhattanDistance","Math","abs","greedy","PathfindingVisualizer","state","mouseIsPressed","start_row","start_col","finish_row","finish_col","setStart","setFinish","currentRow","createNode","newGrid","slice","newNode","getInitialGrid","setState","getNewGridWithWallToggled","r","c","n","newN","document","getElementById","i","setTimeout","animateShortestPath","clearPath","animateDijkstra","visitedNodes","BFS","nodeShortestPathOrder","pop","DFS","onClick","visualizeDijkstra","visualizeBFS","visualizeDFS","visualizeAStar","visualizeGreedy","clearBoard","map","rowIdx","key","nodeIdx","handleMouseMove","handleMouseDown","handleMouseEnter","handleMouseUp","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.56322f26.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\n\r\nimport \"./Node.css\";\r\n\r\nexport default class Node extends Component {\r\n  render() {\r\n    const {\r\n      col,\r\n      row,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseMove,\r\n      onMouseUp,\r\n      f,\r\n      h\r\n    } = this.props;\r\n    const extraClassName = isFinish\r\n      ? \"node-finish\"\r\n      : isStart\r\n      ? \"node-start\"\r\n      : isWall\r\n      ? \"node-wall\"\r\n      : \"\";\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col, isFinish, isStart)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseMove={() => onMouseMove(row, col)}\r\n        onMouseUp={() => onMouseUp()}\r\n      ></div>\r\n    );\r\n  }\r\n}\r\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\r\n// in which they were visited. Also makes nodes point back to their\r\n// previous node, effectively allowing us to compute the shortest path\r\n// by backtracking from the finish node.\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  while (!!unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If we encounter a wall, we skip it.\r\n    if (closestNode.isWall) continue;\r\n    // If the closest node is at a distance of infinity,\r\n    // we must be trapped and should therefore stop.\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    const distance = getDistance(node, neighbor);\r\n    const distanceToCompare = node.distance + distance;\r\n    if (distanceToCompare < neighbor.distance) {\r\n      neighbor.distance = distanceToCompare;\r\n      neighbor.previousNode = node;\r\n    }\r\n  }\r\n}\r\nfunction getDistance(node1, node2) {\r\n  const x1 = node1.row;\r\n  const x2 = node2.row;\r\n  const y1 = node1.col;\r\n  const y2 = node2.col;\r\n  if (x2 < x1 && y1 === y2) return 3;\r\n  else if (x2 > x1 && y1 === y2) return 3;\r\n  else if (y2 < y1 && x1 === x2) return 1;\r\n  else if (y2 > y1 && x1 === x2) return 1;\r\n}\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","export function BFS(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n\r\n  const unvisitedNodes = [startNode];\r\n  while (!!unvisitedNodes.length) {\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If we encounter a wall, we skip it.\r\n    if (closestNode.isWall) continue;\r\n\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    updateUnvisitedNeighbors(closestNode, grid, unvisitedNodes);\r\n  }\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid, unvisitedNodes) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.isVisited = true;\r\n    unvisitedNodes.push(neighbor);\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\nexport function shortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","export function DFS(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n\r\n  const unvisitedNodes = [startNode];\r\n  while (!!unvisitedNodes.length) {\r\n    const closestNode = unvisitedNodes.pop();\r\n\r\n    // If we encounter a wall, we skip it.\r\n    if (closestNode.isWall) continue;\r\n\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    updateUnvisitedNeighbors(closestNode, grid, unvisitedNodes);\r\n  }\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid, unvisitedNodes) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    unvisitedNodes.push(neighbor);\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbors.unshift(grid[row - 1][col]);\r\n  if (col < grid[0].length - 1) neighbors.unshift(grid[row][col + 1]);\r\n  if (row < grid.length - 1) neighbors.unshift(grid[row + 1][col]);\r\n  if (col > 0) neighbors.unshift(grid[row][col - 1]);\r\n\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n","export function aStar(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  startNode.f = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  while (!!unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If we encounter a wall, we skip it.\r\n    if (closestNode.isWall) continue;\r\n\r\n    // If the closest node is at a distance of infinity,\r\n    // we must be trapped and should therefore stop.\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    updateUnvisitedNeighbors(closestNode, grid, finishNode);\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.f - nodeB.f);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid, finishNode) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    const distance = getDistance(node, neighbor);\r\n    if (neighbor.h === Infinity) {\r\n      neighbor.h = manhattanDistance(neighbor, finishNode);\r\n    }\r\n\r\n    const distanceToCompare = node.distance + distance;\r\n    if (distanceToCompare < neighbor.distance) {\r\n      neighbor.distance = distanceToCompare;\r\n      neighbor.previousNode = node;\r\n      neighbor.f = neighbor.distance + neighbor.h;\r\n    }\r\n  }\r\n}\r\nfunction manhattanDistance(node1, node2) {\r\n  const d1 = Math.abs(node1.row - node2.row);\r\n  const d2 = Math.abs(node1.col - node2.col);\r\n  return d1 + d2;\r\n}\r\nfunction getDistance(node1, node2) {\r\n  const x1 = node1.row;\r\n  const x2 = node2.row;\r\n  const y1 = node1.col;\r\n  const y2 = node2.col;\r\n  if (x2 < x1 && y1 === y2) return 3;\r\n  else if (x2 > x1 && y1 === y2) return 3;\r\n  else if (y2 < y1 && x1 === x2) return 1;\r\n  else if (y2 > y1 && x1 === x2) return 1;\r\n}\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n","export function greedy(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  while (!!unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If we encounter a wall, we skip it.\r\n    if (closestNode.isWall) continue;\r\n    // If the closest node is at a distance of infinity,\r\n    // we must be trapped and should therefore stop.\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    updateUnvisitedNeighbors(closestNode, grid, finishNode);\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid, finishNode) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    const distance = getDistance(node, neighbor);\r\n    const distanceToCompare =\r\n      manhattanDistance(neighbor, finishNode) + distance;\r\n    if (distanceToCompare < neighbor.distance) {\r\n      neighbor.distance = distanceToCompare;\r\n      neighbor.previousNode = node;\r\n    }\r\n  }\r\n}\r\nfunction manhattanDistance(node1, node2) {\r\n  const d1 = Math.abs(node1.row - node2.row);\r\n  const d2 = Math.abs(node1.col - node2.col);\r\n  return d1 + d2;\r\n}\r\nfunction getDistance(node1, node2) {\r\n  const x1 = node1.row;\r\n  const x2 = node2.row;\r\n  const y1 = node1.col;\r\n  const y2 = node2.col;\r\n  if (x2 < x1 && y1 === y2) return 3;\r\n  else if (x2 > x1 && y1 === y2) return 3;\r\n  else if (y2 < y1 && x1 === x2) return 1;\r\n  else if (y2 > y1 && x1 === x2) return 1;\r\n}\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","import React, { Component } from \"react\";\r\nimport Node from \"./Node/Node\";\r\nimport { dijkstra, getNodesInShortestPathOrder } from \"./algorithms/dijkstra\";\r\nimport { BFS, shortestPathOrder } from \"./algorithms/BFS\";\r\nimport { DFS } from \"./algorithms/DFS\";\r\nimport { aStar } from \"./algorithms/aStar\";\r\nimport { greedy } from \"./algorithms/greedy\";\r\nimport \"./PathfindingVisualizer.css\";\r\n\r\nexport default class PathfindingVisualizer extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      grid: [],\r\n      mouseIsPressed: false,\r\n      start_row: 10,\r\n      start_col: 10,\r\n      finish_row: 10,\r\n      finish_col: 35,\r\n      setStart: false,\r\n      setFinish: false\r\n    };\r\n  }\r\n  createNode(col, row) {\r\n    return {\r\n      col,\r\n      row,\r\n      isStart: row === this.state.start_row && col === this.state.start_col,\r\n      isFinish: row === this.state.finish_row && col === this.state.finish_col,\r\n      distance: Infinity,\r\n      isVisited: false,\r\n      isWall: false,\r\n      previousNode: null,\r\n      f: Infinity,\r\n      h: Infinity\r\n    };\r\n  }\r\n  getInitialGrid() {\r\n    const grid = [];\r\n    for (let row = 0; row < 25; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < 42; col++) {\r\n        const node = this.createNode(col, row);\r\n        currentRow.push(node);\r\n      }\r\n      grid.push(currentRow);\r\n    }\r\n    return grid;\r\n  }\r\n\r\n  getNewGridWithWallToggled(grid, row, col) {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n      ...node,\r\n      isWall: !node.isWall\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n  }\r\n\r\n  componentDidMount() {\r\n    const grid = this.getInitialGrid();\r\n    this.setState({ grid });\r\n  }\r\n\r\n  handleMouseDown(row, col, isFinish, isStart) {\r\n    if (isFinish) {\r\n      this.setState({ setFinish: true });\r\n    } else if (isStart) {\r\n      this.setState({ setStart: true });\r\n    } else {\r\n      const newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\r\n      this.setState({ grid: newGrid, mouseIsPressed: true });\r\n    }\r\n  }\r\n\r\n  handleMouseMove(row, col) {\r\n    if (this.state.setFinish) {\r\n      for (let r = 0; r < 25; r++) {\r\n        for (let c = 0; c < 42; c++) {\r\n          const n = this.state.grid[r][c];\r\n          if (n.isFinish) {\r\n            const newN = {\r\n              ...n,\r\n              isFinish: !n.isFinish\r\n            };\r\n            this.state.grid[r][c] = newN;\r\n          }\r\n        }\r\n      }\r\n      const node = this.state.grid[row][col];\r\n      const newNode = {\r\n        ...node,\r\n        isFinish: true\r\n      };\r\n      this.state.grid[row][col] = newNode;\r\n      this.setState({ finish_row: row, finish_col: col });\r\n    } else if (this.state.setStart) {\r\n      for (let r = 0; r < 25; r++) {\r\n        for (let c = 0; c < 42; c++) {\r\n          const n = this.state.grid[r][c];\r\n          if (n.isStart) {\r\n            const newN = {\r\n              ...n,\r\n              isStart: !n.isStart\r\n            };\r\n            this.state.grid[r][c] = newN;\r\n          }\r\n        }\r\n      }\r\n      const node = this.state.grid[row][col];\r\n      const newNode = {\r\n        ...node,\r\n        isStart: true\r\n      };\r\n      this.state.grid[row][col] = newNode;\r\n      this.setState({ start_row: row, start_col: col });\r\n    }\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.mouseIsPressed) return;\r\n    const newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\r\n    this.setState({ grid: newGrid });\r\n  }\r\n\r\n  handleMouseUp() {\r\n    this.setState({ mouseIsPressed: false, setFinish: false, setStart: false });\r\n  }\r\n  clearBoard() {\r\n    const { grid } = this.state;\r\n\r\n    for (let row = 0; row < 25; row++) {\r\n      for (let col = 0; col < 42; col++) {\r\n        const node = grid[row][col];\r\n        if (node.isStart || node.isFinish) {\r\n        } else {\r\n          document.getElementById(`node-${row}-${col}`).className = \"node \";\r\n        }\r\n        node.isWall = false;\r\n        node.distance = Infinity;\r\n        node.isVisited = false;\r\n        node.previousNode = null;\r\n        node.f = Infinity;\r\n        node.h = Infinity;\r\n        grid[row][col] = node;\r\n      }\r\n    }\r\n    this.setState({ grid });\r\n  }\r\n  clearPath() {\r\n    const { grid } = this.state;\r\n\r\n    for (let row = 0; row < 25; row++) {\r\n      for (let col = 0; col < 42; col++) {\r\n        const node = grid[row][col];\r\n        if (node.isStart || node.isFinish || node.isWall) {\r\n        } else {\r\n          document.getElementById(`node-${row}-${col}`).className = \"node \";\r\n          node.isWall = false;\r\n        }\r\n        node.distance = Infinity;\r\n        node.isVisited = false;\r\n        node.previousNode = null;\r\n        node.f = Infinity;\r\n        node.h = Infinity;\r\n        grid[row][col] = node;\r\n      }\r\n    }\r\n    this.setState({ grid });\r\n  }\r\n\r\n  animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 1; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length - 1) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, 6 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-visited\";\r\n      }, 5 * i);\r\n    }\r\n  }\r\n\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 2; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i - 1];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-shortest-path\";\r\n      }, 25 * i);\r\n    }\r\n  }\r\n\r\n  visualizeDijkstra() {\r\n    this.clearPath();\r\n    const { grid } = this.state;\r\n    const startNode = grid[this.state.start_row][this.state.start_col];\r\n    const finishNode = grid[this.state.finish_row][this.state.finish_col];\r\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n\r\n  visualizeAStar() {\r\n    this.clearPath();\r\n    const { grid } = this.state;\r\n    const startNode = grid[this.state.start_row][this.state.start_col];\r\n    const finishNode = grid[this.state.finish_row][this.state.finish_col];\r\n    const visitedNodesInOrder = aStar(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n\r\n  visualizeGreedy() {\r\n    this.clearPath();\r\n    const { grid } = this.state;\r\n    const startNode = grid[this.state.start_row][this.state.start_col];\r\n    const finishNode = grid[this.state.finish_row][this.state.finish_col];\r\n    const visitedNodesInOrder = greedy(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n\r\n  visualizeBFS() {\r\n    this.clearPath();\r\n    const { grid } = this.state;\r\n    const startNode = grid[this.state.start_row][this.state.start_col];\r\n    const finishNode = grid[this.state.finish_row][this.state.finish_col];\r\n    const visitedNodes = BFS(grid, startNode, finishNode);\r\n    const nodeShortestPathOrder = shortestPathOrder(finishNode);\r\n    this.animateDijkstra(visitedNodes, nodeShortestPathOrder);\r\n  }\r\n\r\n  visualizeDFS() {\r\n    this.clearPath();\r\n    const { grid } = this.state;\r\n    const startNode = grid[this.state.start_row][this.state.start_col];\r\n    const finishNode = grid[this.state.finish_row][this.state.finish_col];\r\n    const visitedNodes = DFS(grid, startNode, finishNode);\r\n    const nodeShortestPathOrder = shortestPathOrder(finishNode);\r\n    this.animateDijkstra(visitedNodes, nodeShortestPathOrder);\r\n  }\r\n  render() {\r\n    const { grid, mouseIsPressed } = this.state;\r\n\r\n    return (\r\n      <>\r\n        <div className=\"bars\">\r\n          <button onClick={() => this.visualizeDijkstra()}>\r\n            Dijkstra's Algorithm\r\n          </button>\r\n          <button onClick={() => this.visualizeBFS()}>\r\n            Breadth-first Search Algorithm\r\n          </button>\r\n          <button onClick={() => this.visualizeDFS()}>\r\n            Depth-first Search Algorithm\r\n          </button>\r\n          <button onClick={() => this.visualizeAStar()}>\r\n            A * Search Algorithm\r\n          </button>\r\n          <button onClick={() => this.visualizeGreedy()}>\r\n            Greedy Best-first Search Algorithm\r\n          </button>\r\n          <button onClick={() => this.clearBoard()}>Clear Board</button>\r\n          <button onClick={() => this.clearPath()}>Clear Path</button>\r\n        </div>\r\n        <div className=\"grid\">\r\n          {grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx}>\r\n                {row.map((node, nodeIdx) => {\r\n                  const { row, col, isFinish, isStart, isWall } = node;\r\n                  return (\r\n                    <Node\r\n                      key={nodeIdx}\r\n                      col={col}\r\n                      row={row}\r\n                      isFinish={isFinish}\r\n                      isStart={isStart}\r\n                      isWall={isWall}\r\n                      mouseIsPressed={mouseIsPressed}\r\n                      onMouseMove={(row, col) => this.handleMouseMove(row, col)}\r\n                      onMouseDown={(row, col, isFinish, isStart) =>\r\n                        this.handleMouseDown(row, col, isFinish, isStart)\r\n                      }\r\n                      onMouseEnter={(row, col) =>\r\n                        this.handleMouseEnter(row, col)\r\n                      }\r\n                      onMouseMove={(row, col) => this.handleMouseMove(row, col)}\r\n                      onMouseUp={() => this.handleMouseUp()}\r\n                    ></Node>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n","import React from \"react\";\nimport \"./App.css\";\nimport HighlightIcon from \"@material-ui/icons/Highlight\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header>\n        <h1>\n          <HighlightIcon />\n          Path Visualizer\n        </h1>\n      </header>\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n"],"sourceRoot":""}