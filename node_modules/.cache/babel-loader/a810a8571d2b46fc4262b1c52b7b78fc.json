{"ast":null,"code":"export function aStar(grid,startNode,finishNode){var visitedNodesInOrder=[];startNode.distance=0;startNode.f=0;var unvisitedNodes=getAllNodes(grid);while(!!unvisitedNodes.length){sortNodesByDistance(unvisitedNodes);var closestNode=unvisitedNodes.shift();// If we encounter a wall, we skip it.\nif(closestNode.isWall)continue;// If the closest node is at a distance of infinity,\n// we must be trapped and should therefore stop.\nif(closestNode.distance===Infinity)return visitedNodesInOrder;closestNode.isVisited=true;visitedNodesInOrder.push(closestNode);if(closestNode===finishNode)return visitedNodesInOrder;updateUnvisitedNeighbors(closestNode,grid,finishNode);}}function sortNodesByDistance(unvisitedNodes){unvisitedNodes.sort(function(nodeA,nodeB){return nodeA.f-nodeB.f;});}function updateUnvisitedNeighbors(node,grid,finishNode){var unvisitedNeighbors=getUnvisitedNeighbors(node,grid);var _iteratorNormalCompletion=true;var _didIteratorError=false;var _iteratorError=undefined;try{for(var _iterator=unvisitedNeighbors[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=true){var neighbor=_step.value;var distance=getDistance(node,neighbor);if(neighbor.h===Infinity){neighbor.h=manhattanDistance(neighbor,finishNode);}var distanceToCompare=node.distance+distance;if(distanceToCompare<neighbor.distance){neighbor.distance=distanceToCompare;neighbor.previousNode=node;neighbor.f=neighbor.distance+neighbor.h;}}}catch(err){_didIteratorError=true;_iteratorError=err;}finally{try{if(!_iteratorNormalCompletion&&_iterator.return!=null){_iterator.return();}}finally{if(_didIteratorError){throw _iteratorError;}}}}function manhattanDistance(node1,node2){var d1=Math.abs(node1.row-node2.row);var d2=Math.abs(node1.col-node2.col);return d1+d2;}function getDistance(node1,node2){var x1=node1.row;var x2=node2.row;var y1=node1.col;var y2=node2.col;if(x2<x1&&y1===y2)return 3;else if(x2>x1&&y1===y2)return 3;else if(y2<y1&&x1===x2)return 1;else if(y2>y1&&x1===x2)return 1;}function getUnvisitedNeighbors(node,grid){var neighbors=[];var col=node.col,row=node.row;if(row>0)neighbors.push(grid[row-1][col]);if(row<grid.length-1)neighbors.push(grid[row+1][col]);if(col>0)neighbors.push(grid[row][col-1]);if(col<grid[0].length-1)neighbors.push(grid[row][col+1]);return neighbors.filter(function(neighbor){return!neighbor.isVisited;});}function getAllNodes(grid){var nodes=[];var _iteratorNormalCompletion2=true;var _didIteratorError2=false;var _iteratorError2=undefined;try{for(var _iterator2=grid[Symbol.iterator](),_step2;!(_iteratorNormalCompletion2=(_step2=_iterator2.next()).done);_iteratorNormalCompletion2=true){var row=_step2.value;var _iteratorNormalCompletion3=true;var _didIteratorError3=false;var _iteratorError3=undefined;try{for(var _iterator3=row[Symbol.iterator](),_step3;!(_iteratorNormalCompletion3=(_step3=_iterator3.next()).done);_iteratorNormalCompletion3=true){var node=_step3.value;nodes.push(node);}}catch(err){_didIteratorError3=true;_iteratorError3=err;}finally{try{if(!_iteratorNormalCompletion3&&_iterator3.return!=null){_iterator3.return();}}finally{if(_didIteratorError3){throw _iteratorError3;}}}}}catch(err){_didIteratorError2=true;_iteratorError2=err;}finally{try{if(!_iteratorNormalCompletion2&&_iterator2.return!=null){_iterator2.return();}}finally{if(_didIteratorError2){throw _iteratorError2;}}}return nodes;}","map":{"version":3,"sources":["/Users/tianjiaoqu/Documents/USC/CS571/pathVisualizer/src/PathfindingVisualizer/algorithms/aStar.js"],"names":["aStar","grid","startNode","finishNode","visitedNodesInOrder","distance","f","unvisitedNodes","getAllNodes","length","sortNodesByDistance","closestNode","shift","isWall","Infinity","isVisited","push","updateUnvisitedNeighbors","sort","nodeA","nodeB","node","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","getDistance","h","manhattanDistance","distanceToCompare","previousNode","node1","node2","d1","Math","abs","row","d2","col","x1","x2","y1","y2","neighbors","filter","nodes"],"mappings":"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","sourcesContent":["export function aStar(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  startNode.f = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid, finishNode);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.f - nodeB.f);\n}\n\nfunction updateUnvisitedNeighbors(node, grid, finishNode) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    const distance = getDistance(node, neighbor);\n    if (neighbor.h === Infinity) {\n      neighbor.h = manhattanDistance(neighbor, finishNode);\n    }\n\n    const distanceToCompare = node.distance + distance;\n    if (distanceToCompare < neighbor.distance) {\n      neighbor.distance = distanceToCompare;\n      neighbor.previousNode = node;\n      neighbor.f = neighbor.distance + neighbor.h;\n    }\n  }\n}\nfunction manhattanDistance(node1, node2) {\n  const d1 = Math.abs(node1.row - node2.row);\n  const d2 = Math.abs(node1.col - node2.col);\n  return d1 + d2;\n}\nfunction getDistance(node1, node2) {\n  const x1 = node1.row;\n  const x2 = node2.row;\n  const y1 = node1.col;\n  const y2 = node2.col;\n  if (x2 < x1 && y1 === y2) return 3;\n  else if (x2 > x1 && y1 === y2) return 3;\n  else if (y2 < y1 && x1 === x2) return 1;\n  else if (y2 > y1 && x1 === x2) return 1;\n}\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n"]},"metadata":{},"sourceType":"module"}