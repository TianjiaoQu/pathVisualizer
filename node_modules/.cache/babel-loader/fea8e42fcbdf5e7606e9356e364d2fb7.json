{"ast":null,"code":"export function BFS(grid,startNode,finishNode){var visitedNodesInOrder=[];var unvisitedNodes=[startNode];while(!!unvisitedNodes.length){var closestNode=unvisitedNodes.shift();// If we encounter a wall, we skip it.\nif(closestNode.isWall)continue;closestNode.isVisited=true;visitedNodesInOrder.push(closestNode);if(closestNode===finishNode)return visitedNodesInOrder;updateUnvisitedNeighbors(closestNode,grid,unvisitedNodes);}}function updateUnvisitedNeighbors(node,grid,unvisitedNodes){var unvisitedNeighbors=getUnvisitedNeighbors(node,grid);var _iteratorNormalCompletion=true;var _didIteratorError=false;var _iteratorError=undefined;try{for(var _iterator=unvisitedNeighbors[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=true){var neighbor=_step.value;neighbor.isVisited=true;unvisitedNodes.push(neighbor);neighbor.previousNode=node;}}catch(err){_didIteratorError=true;_iteratorError=err;}finally{try{if(!_iteratorNormalCompletion&&_iterator.return!=null){_iterator.return();}}finally{if(_didIteratorError){throw _iteratorError;}}}}function getUnvisitedNeighbors(node,grid){var neighbors=[];var col=node.col,row=node.row;if(row>0)neighbors.push(grid[row-1][col]);if(row<grid.length-1)neighbors.push(grid[row+1][col]);if(col>0)neighbors.push(grid[row][col-1]);if(col<grid[0].length-1)neighbors.push(grid[row][col+1]);return neighbors.filter(function(neighbor){return!neighbor.isVisited;});}export function shortestPathOrder(finishNode){var nodesInShortestPathOrder=[];var currentNode=finishNode;while(currentNode!==null){nodesInShortestPathOrder.unshift(currentNode);currentNode=currentNode.previousNode;}return nodesInShortestPathOrder;}","map":{"version":3,"sources":["/Users/tianjiaoqu/Documents/USC/CS571/pathVisualizer/src/PathfindingVisualizer/algorithms/BFS.js"],"names":["BFS","grid","startNode","finishNode","visitedNodesInOrder","unvisitedNodes","length","closestNode","shift","isWall","isVisited","push","updateUnvisitedNeighbors","node","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","previousNode","neighbors","col","row","filter","shortestPathOrder","nodesInShortestPathOrder","currentNode","unshift"],"mappings":"AAAA,MAAO,SAASA,CAAAA,GAAT,CAAaC,IAAb,CAAmBC,SAAnB,CAA8BC,UAA9B,CAA0C,CAC/C,GAAMC,CAAAA,mBAAmB,CAAG,EAA5B,CAEA,GAAMC,CAAAA,cAAc,CAAG,CAACH,SAAD,CAAvB,CACA,MAAO,CAAC,CAACG,cAAc,CAACC,MAAxB,CAAgC,CAC9B,GAAMC,CAAAA,WAAW,CAAGF,cAAc,CAACG,KAAf,EAApB,CACA;AACA,GAAID,WAAW,CAACE,MAAhB,CAAwB,SAExBF,WAAW,CAACG,SAAZ,CAAwB,IAAxB,CACAN,mBAAmB,CAACO,IAApB,CAAyBJ,WAAzB,EACA,GAAIA,WAAW,GAAKJ,UAApB,CAAgC,MAAOC,CAAAA,mBAAP,CAChCQ,wBAAwB,CAACL,WAAD,CAAcN,IAAd,CAAoBI,cAApB,CAAxB,CACD,CACF,CAED,QAASO,CAAAA,wBAAT,CAAkCC,IAAlC,CAAwCZ,IAAxC,CAA8CI,cAA9C,CAA8D,CAC5D,GAAMS,CAAAA,kBAAkB,CAAGC,qBAAqB,CAACF,IAAD,CAAOZ,IAAP,CAAhD,CAD4D,gGAE5D,kBAAuBa,kBAAvB,oHAA2C,IAAhCE,CAAAA,QAAgC,aACzCA,QAAQ,CAACN,SAAT,CAAqB,IAArB,CACAL,cAAc,CAACM,IAAf,CAAoBK,QAApB,EACAA,QAAQ,CAACC,YAAT,CAAwBJ,IAAxB,CACD,CAN2D,qMAO7D,CAED,QAASE,CAAAA,qBAAT,CAA+BF,IAA/B,CAAqCZ,IAArC,CAA2C,CACzC,GAAMiB,CAAAA,SAAS,CAAG,EAAlB,CADyC,GAEjCC,CAAAA,GAFiC,CAEpBN,IAFoB,CAEjCM,GAFiC,CAE5BC,GAF4B,CAEpBP,IAFoB,CAE5BO,GAF4B,CAGzC,GAAIA,GAAG,CAAG,CAAV,CAAaF,SAAS,CAACP,IAAV,CAAeV,IAAI,CAACmB,GAAG,CAAG,CAAP,CAAJ,CAAcD,GAAd,CAAf,EACb,GAAIC,GAAG,CAAGnB,IAAI,CAACK,MAAL,CAAc,CAAxB,CAA2BY,SAAS,CAACP,IAAV,CAAeV,IAAI,CAACmB,GAAG,CAAG,CAAP,CAAJ,CAAcD,GAAd,CAAf,EAC3B,GAAIA,GAAG,CAAG,CAAV,CAAaD,SAAS,CAACP,IAAV,CAAeV,IAAI,CAACmB,GAAD,CAAJ,CAAUD,GAAG,CAAG,CAAhB,CAAf,EACb,GAAIA,GAAG,CAAGlB,IAAI,CAAC,CAAD,CAAJ,CAAQK,MAAR,CAAiB,CAA3B,CAA8BY,SAAS,CAACP,IAAV,CAAeV,IAAI,CAACmB,GAAD,CAAJ,CAAUD,GAAG,CAAG,CAAhB,CAAf,EAC9B,MAAOD,CAAAA,SAAS,CAACG,MAAV,CAAiB,SAAAL,QAAQ,QAAI,CAACA,QAAQ,CAACN,SAAd,EAAzB,CAAP,CACD,CAED,MAAO,SAASY,CAAAA,iBAAT,CAA2BnB,UAA3B,CAAuC,CAC5C,GAAMoB,CAAAA,wBAAwB,CAAG,EAAjC,CACA,GAAIC,CAAAA,WAAW,CAAGrB,UAAlB,CACA,MAAOqB,WAAW,GAAK,IAAvB,CAA6B,CAC3BD,wBAAwB,CAACE,OAAzB,CAAiCD,WAAjC,EACAA,WAAW,CAAGA,WAAW,CAACP,YAA1B,CACD,CACD,MAAOM,CAAAA,wBAAP,CACD","sourcesContent":["export function BFS(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n\n  const unvisitedNodes = [startNode];\n  while (!!unvisitedNodes.length) {\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid, unvisitedNodes);\n  }\n}\n\nfunction updateUnvisitedNeighbors(node, grid, unvisitedNodes) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.isVisited = true;\n    unvisitedNodes.push(neighbor);\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nexport function shortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n"]},"metadata":{},"sourceType":"module"}