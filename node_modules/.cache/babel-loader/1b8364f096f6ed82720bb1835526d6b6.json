{"ast":null,"code":"export function DFS(grid,startNode,finishNode){var visitedNodesInOrder=[];var unvisitedNodes=[startNode];while(!!unvisitedNodes.length){var closestNode=unvisitedNodes.pop();// If we encounter a wall, we skip it.\nif(closestNode.isWall)continue;closestNode.isVisited=true;visitedNodesInOrder.push(closestNode);if(closestNode===finishNode)return visitedNodesInOrder;updateUnvisitedNeighbors(closestNode,grid,unvisitedNodes);}}function updateUnvisitedNeighbors(node,grid,unvisitedNodes){var unvisitedNeighbors=getUnvisitedNeighbors(node,grid);var _iteratorNormalCompletion=true;var _didIteratorError=false;var _iteratorError=undefined;try{for(var _iterator=unvisitedNeighbors[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=true){var neighbor=_step.value;unvisitedNodes.push(neighbor);neighbor.previousNode=node;}}catch(err){_didIteratorError=true;_iteratorError=err;}finally{try{if(!_iteratorNormalCompletion&&_iterator.return!=null){_iterator.return();}}finally{if(_didIteratorError){throw _iteratorError;}}}}function getUnvisitedNeighbors(node,grid){var neighbors=[];var col=node.col,row=node.row;if(row>0)neighbors.unshift(grid[row-1][col]);if(col<grid[0].length-1)neighbors.unshift(grid[row][col+1]);if(row<grid.length-1)neighbors.unshift(grid[row+1][col]);if(col>0)neighbors.unshift(grid[row][col-1]);return neighbors.filter(function(neighbor){return!neighbor.isVisited;});}","map":{"version":3,"sources":["/Users/tianjiaoqu/Documents/USC/CS571/pathVisualizer/src/PathfindingVisualizer/algorithms/DFS.js"],"names":["DFS","grid","startNode","finishNode","visitedNodesInOrder","unvisitedNodes","length","closestNode","pop","isWall","isVisited","push","updateUnvisitedNeighbors","node","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","previousNode","neighbors","col","row","unshift","filter"],"mappings":"AAAA,MAAO,SAASA,CAAAA,GAAT,CAAaC,IAAb,CAAmBC,SAAnB,CAA8BC,UAA9B,CAA0C,CAC/C,GAAMC,CAAAA,mBAAmB,CAAG,EAA5B,CAEA,GAAMC,CAAAA,cAAc,CAAG,CAACH,SAAD,CAAvB,CACA,MAAO,CAAC,CAACG,cAAc,CAACC,MAAxB,CAAgC,CAC9B,GAAMC,CAAAA,WAAW,CAAGF,cAAc,CAACG,GAAf,EAApB,CAEA;AACA,GAAID,WAAW,CAACE,MAAhB,CAAwB,SAExBF,WAAW,CAACG,SAAZ,CAAwB,IAAxB,CACAN,mBAAmB,CAACO,IAApB,CAAyBJ,WAAzB,EACA,GAAIA,WAAW,GAAKJ,UAApB,CAAgC,MAAOC,CAAAA,mBAAP,CAChCQ,wBAAwB,CAACL,WAAD,CAAcN,IAAd,CAAoBI,cAApB,CAAxB,CACD,CACF,CAED,QAASO,CAAAA,wBAAT,CAAkCC,IAAlC,CAAwCZ,IAAxC,CAA8CI,cAA9C,CAA8D,CAC5D,GAAMS,CAAAA,kBAAkB,CAAGC,qBAAqB,CAACF,IAAD,CAAOZ,IAAP,CAAhD,CAD4D,gGAE5D,kBAAuBa,kBAAvB,oHAA2C,IAAhCE,CAAAA,QAAgC,aACzCX,cAAc,CAACM,IAAf,CAAoBK,QAApB,EACAA,QAAQ,CAACC,YAAT,CAAwBJ,IAAxB,CACD,CAL2D,qMAM7D,CAED,QAASE,CAAAA,qBAAT,CAA+BF,IAA/B,CAAqCZ,IAArC,CAA2C,CACzC,GAAMiB,CAAAA,SAAS,CAAG,EAAlB,CADyC,GAEjCC,CAAAA,GAFiC,CAEpBN,IAFoB,CAEjCM,GAFiC,CAE5BC,GAF4B,CAEpBP,IAFoB,CAE5BO,GAF4B,CAGzC,GAAIA,GAAG,CAAG,CAAV,CAAaF,SAAS,CAACG,OAAV,CAAkBpB,IAAI,CAACmB,GAAG,CAAG,CAAP,CAAJ,CAAcD,GAAd,CAAlB,EACb,GAAIA,GAAG,CAAGlB,IAAI,CAAC,CAAD,CAAJ,CAAQK,MAAR,CAAiB,CAA3B,CAA8BY,SAAS,CAACG,OAAV,CAAkBpB,IAAI,CAACmB,GAAD,CAAJ,CAAUD,GAAG,CAAG,CAAhB,CAAlB,EAC9B,GAAIC,GAAG,CAAGnB,IAAI,CAACK,MAAL,CAAc,CAAxB,CAA2BY,SAAS,CAACG,OAAV,CAAkBpB,IAAI,CAACmB,GAAG,CAAG,CAAP,CAAJ,CAAcD,GAAd,CAAlB,EAC3B,GAAIA,GAAG,CAAG,CAAV,CAAaD,SAAS,CAACG,OAAV,CAAkBpB,IAAI,CAACmB,GAAD,CAAJ,CAAUD,GAAG,CAAG,CAAhB,CAAlB,EAEb,MAAOD,CAAAA,SAAS,CAACI,MAAV,CAAiB,SAAAN,QAAQ,QAAI,CAACA,QAAQ,CAACN,SAAd,EAAzB,CAAP,CACD","sourcesContent":["export function DFS(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n\n  const unvisitedNodes = [startNode];\n  while (!!unvisitedNodes.length) {\n    const closestNode = unvisitedNodes.pop();\n\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid, unvisitedNodes);\n  }\n}\n\nfunction updateUnvisitedNeighbors(node, grid, unvisitedNodes) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    unvisitedNodes.push(neighbor);\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.unshift(grid[row - 1][col]);\n  if (col < grid[0].length - 1) neighbors.unshift(grid[row][col + 1]);\n  if (row < grid.length - 1) neighbors.unshift(grid[row + 1][col]);\n  if (col > 0) neighbors.unshift(grid[row][col - 1]);\n\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n"]},"metadata":{},"sourceType":"module"}