{"ast":null,"code":"export function BFS(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  const unvisitedNodes = [startNode];\n\n  while (!!unvisitedNodes.length) {\n    const closestNode = unvisitedNodes.shift(); // If we encounter a wall, we skip it.\n\n    if (closestNode.isWall) continue;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid, unvisitedNodes);\n  }\n}\n\nfunction updateUnvisitedNeighbors(node, grid, unvisitedNodes) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.isVisited = true;\n    unvisitedNodes.push(neighbor);\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const col = node.col,\n        row = node.row;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nexport function shortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"sources":["/Users/tianjiaoqu/Documents/USC/CS571/pathVisualizer/src/PathfindingVisualizer/algorithms/BFS.js"],"names":["BFS","grid","startNode","finishNode","visitedNodesInOrder","unvisitedNodes","length","closestNode","shift","isWall","isVisited","push","updateUnvisitedNeighbors","node","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","previousNode","neighbors","col","row","filter","shortestPathOrder","nodesInShortestPathOrder","currentNode","unshift"],"mappings":"AAAA,OAAO,SAASA,GAAT,CAAaC,IAAb,EAAmBC,SAAnB,EAA8BC,UAA9B,EAA0C;AAC/C,QAAMC,mBAAmB,GAAG,EAA5B;AAEA,QAAMC,cAAc,GAAG,CAACH,SAAD,CAAvB;;AACA,SAAO,CAAC,CAACG,cAAc,CAACC,MAAxB,EAAgC;AAC9B,UAAMC,WAAW,GAAGF,cAAc,CAACG,KAAf,EAApB,CAD8B,CAE9B;;AACA,QAAID,WAAW,CAACE,MAAhB,EAAwB;AAExBF,IAAAA,WAAW,CAACG,SAAZ,GAAwB,IAAxB;AACAN,IAAAA,mBAAmB,CAACO,IAApB,CAAyBJ,WAAzB;AACA,QAAIA,WAAW,KAAKJ,UAApB,EAAgC,OAAOC,mBAAP;AAChCQ,IAAAA,wBAAwB,CAACL,WAAD,EAAcN,IAAd,EAAoBI,cAApB,CAAxB;AACD;AACF;;AAED,SAASO,wBAAT,CAAkCC,IAAlC,EAAwCZ,IAAxC,EAA8CI,cAA9C,EAA8D;AAC5D,QAAMS,kBAAkB,GAAGC,qBAAqB,CAACF,IAAD,EAAOZ,IAAP,CAAhD;;AACA,OAAK,MAAMe,QAAX,IAAuBF,kBAAvB,EAA2C;AACzCE,IAAAA,QAAQ,CAACN,SAAT,GAAqB,IAArB;AACAL,IAAAA,cAAc,CAACM,IAAf,CAAoBK,QAApB;AACAA,IAAAA,QAAQ,CAACC,YAAT,GAAwBJ,IAAxB;AACD;AACF;;AAED,SAASE,qBAAT,CAA+BF,IAA/B,EAAqCZ,IAArC,EAA2C;AACzC,QAAMiB,SAAS,GAAG,EAAlB;AADyC,QAEjCC,GAFiC,GAEpBN,IAFoB,CAEjCM,GAFiC;AAAA,QAE5BC,GAF4B,GAEpBP,IAFoB,CAE5BO,GAF4B;AAGzC,MAAIA,GAAG,GAAG,CAAV,EAAaF,SAAS,CAACP,IAAV,CAAeV,IAAI,CAACmB,GAAG,GAAG,CAAP,CAAJ,CAAcD,GAAd,CAAf;AACb,MAAIC,GAAG,GAAGnB,IAAI,CAACK,MAAL,GAAc,CAAxB,EAA2BY,SAAS,CAACP,IAAV,CAAeV,IAAI,CAACmB,GAAG,GAAG,CAAP,CAAJ,CAAcD,GAAd,CAAf;AAC3B,MAAIA,GAAG,GAAG,CAAV,EAAaD,SAAS,CAACP,IAAV,CAAeV,IAAI,CAACmB,GAAD,CAAJ,CAAUD,GAAG,GAAG,CAAhB,CAAf;AACb,MAAIA,GAAG,GAAGlB,IAAI,CAAC,CAAD,CAAJ,CAAQK,MAAR,GAAiB,CAA3B,EAA8BY,SAAS,CAACP,IAAV,CAAeV,IAAI,CAACmB,GAAD,CAAJ,CAAUD,GAAG,GAAG,CAAhB,CAAf;AAC9B,SAAOD,SAAS,CAACG,MAAV,CAAiBL,QAAQ,IAAI,CAACA,QAAQ,CAACN,SAAvC,CAAP;AACD;;AAED,OAAO,SAASY,iBAAT,CAA2BnB,UAA3B,EAAuC;AAC5C,QAAMoB,wBAAwB,GAAG,EAAjC;AACA,MAAIC,WAAW,GAAGrB,UAAlB;;AACA,SAAOqB,WAAW,KAAK,IAAvB,EAA6B;AAC3BD,IAAAA,wBAAwB,CAACE,OAAzB,CAAiCD,WAAjC;AACAA,IAAAA,WAAW,GAAGA,WAAW,CAACP,YAA1B;AACD;;AACD,SAAOM,wBAAP;AACD","sourcesContent":["export function BFS(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n\n  const unvisitedNodes = [startNode];\n  while (!!unvisitedNodes.length) {\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid, unvisitedNodes);\n  }\n}\n\nfunction updateUnvisitedNeighbors(node, grid, unvisitedNodes) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.isVisited = true;\n    unvisitedNodes.push(neighbor);\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nexport function shortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n"]},"metadata":{},"sourceType":"module"}