{"ast":null,"code":"export function DFS(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  const unvisitedNodes = [startNode];\n\n  while (!!unvisitedNodes.length) {\n    const closestNode = unvisitedNodes.pop(); // If we encounter a wall, we skip it.\n\n    if (closestNode.isWall) continue;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid, unvisitedNodes);\n  }\n}\n\nfunction updateUnvisitedNeighbors(node, grid, unvisitedNodes) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n\n  for (const neighbor of unvisitedNeighbors) {\n    unvisitedNodes.push(neighbor);\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const col = node.col,\n        row = node.row;\n  if (row > 0) neighbors.unshift(grid[row - 1][col]);\n  if (col < grid[0].length - 1) neighbors.unshift(grid[row][col + 1]);\n  if (row < grid.length - 1) neighbors.unshift(grid[row + 1][col]);\n  if (col > 0) neighbors.unshift(grid[row][col - 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}","map":{"version":3,"sources":["/Users/tianjiaoqu/Documents/USC/CS571/pathVisualizer/src/PathfindingVisualizer/algorithms/DFS.js"],"names":["DFS","grid","startNode","finishNode","visitedNodesInOrder","unvisitedNodes","length","closestNode","pop","isWall","isVisited","push","updateUnvisitedNeighbors","node","unvisitedNeighbors","getUnvisitedNeighbors","neighbor","previousNode","neighbors","col","row","unshift","filter"],"mappings":"AAAA,OAAO,SAASA,GAAT,CAAaC,IAAb,EAAmBC,SAAnB,EAA8BC,UAA9B,EAA0C;AAC/C,QAAMC,mBAAmB,GAAG,EAA5B;AAEA,QAAMC,cAAc,GAAG,CAACH,SAAD,CAAvB;;AACA,SAAO,CAAC,CAACG,cAAc,CAACC,MAAxB,EAAgC;AAC9B,UAAMC,WAAW,GAAGF,cAAc,CAACG,GAAf,EAApB,CAD8B,CAG9B;;AACA,QAAID,WAAW,CAACE,MAAhB,EAAwB;AAExBF,IAAAA,WAAW,CAACG,SAAZ,GAAwB,IAAxB;AACAN,IAAAA,mBAAmB,CAACO,IAApB,CAAyBJ,WAAzB;AACA,QAAIA,WAAW,KAAKJ,UAApB,EAAgC,OAAOC,mBAAP;AAChCQ,IAAAA,wBAAwB,CAACL,WAAD,EAAcN,IAAd,EAAoBI,cAApB,CAAxB;AACD;AACF;;AAED,SAASO,wBAAT,CAAkCC,IAAlC,EAAwCZ,IAAxC,EAA8CI,cAA9C,EAA8D;AAC5D,QAAMS,kBAAkB,GAAGC,qBAAqB,CAACF,IAAD,EAAOZ,IAAP,CAAhD;;AACA,OAAK,MAAMe,QAAX,IAAuBF,kBAAvB,EAA2C;AACzCT,IAAAA,cAAc,CAACM,IAAf,CAAoBK,QAApB;AACAA,IAAAA,QAAQ,CAACC,YAAT,GAAwBJ,IAAxB;AACD;AACF;;AAED,SAASE,qBAAT,CAA+BF,IAA/B,EAAqCZ,IAArC,EAA2C;AACzC,QAAMiB,SAAS,GAAG,EAAlB;AADyC,QAEjCC,GAFiC,GAEpBN,IAFoB,CAEjCM,GAFiC;AAAA,QAE5BC,GAF4B,GAEpBP,IAFoB,CAE5BO,GAF4B;AAGzC,MAAIA,GAAG,GAAG,CAAV,EAAaF,SAAS,CAACG,OAAV,CAAkBpB,IAAI,CAACmB,GAAG,GAAG,CAAP,CAAJ,CAAcD,GAAd,CAAlB;AACb,MAAIA,GAAG,GAAGlB,IAAI,CAAC,CAAD,CAAJ,CAAQK,MAAR,GAAiB,CAA3B,EAA8BY,SAAS,CAACG,OAAV,CAAkBpB,IAAI,CAACmB,GAAD,CAAJ,CAAUD,GAAG,GAAG,CAAhB,CAAlB;AAC9B,MAAIC,GAAG,GAAGnB,IAAI,CAACK,MAAL,GAAc,CAAxB,EAA2BY,SAAS,CAACG,OAAV,CAAkBpB,IAAI,CAACmB,GAAG,GAAG,CAAP,CAAJ,CAAcD,GAAd,CAAlB;AAC3B,MAAIA,GAAG,GAAG,CAAV,EAAaD,SAAS,CAACG,OAAV,CAAkBpB,IAAI,CAACmB,GAAD,CAAJ,CAAUD,GAAG,GAAG,CAAhB,CAAlB;AAEb,SAAOD,SAAS,CAACI,MAAV,CAAiBN,QAAQ,IAAI,CAACA,QAAQ,CAACN,SAAvC,CAAP;AACD","sourcesContent":["export function DFS(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n\n  const unvisitedNodes = [startNode];\n  while (!!unvisitedNodes.length) {\n    const closestNode = unvisitedNodes.pop();\n\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid, unvisitedNodes);\n  }\n}\n\nfunction updateUnvisitedNeighbors(node, grid, unvisitedNodes) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    unvisitedNodes.push(neighbor);\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.unshift(grid[row - 1][col]);\n  if (col < grid[0].length - 1) neighbors.unshift(grid[row][col + 1]);\n  if (row < grid.length - 1) neighbors.unshift(grid[row + 1][col]);\n  if (col > 0) neighbors.unshift(grid[row][col - 1]);\n\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n"]},"metadata":{},"sourceType":"module"}